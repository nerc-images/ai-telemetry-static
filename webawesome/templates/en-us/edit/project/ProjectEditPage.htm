{% extends "en-us/edit/project/ProjectGenEditPage.htm" %}
{%- block htmBodyStartProjectPage %}
{{ super() }}
{% if result is defined %}
<wa-details open class="HtmRow" id="observability-dashboard">
  <div slot="summary">
    Observability dashboard for OpenShift projects
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      {{ dashboardCard('visualization-cluster-memory-bytes', 'Percent of total memory usage for ' ~ result.clusterName ~ ' cluster') }}
      {{ dashboardCard('visualization-cluster-cpu-bytes', 'Percent of total CPU usage for ' ~ result.clusterName ~ ' cluster') }}
    </div>
  </div>
</wa-details>
<wa-details open class="HtmRow" id="network-performance-dashboard">
  <div slot="summary">
    Network Performance Metrics
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      {{ dashboardCard('visualization-network-receive', 'Network receive bytes in ' ~ result.projectName) }}
      {{ dashboardCard('visualization-network-transmit', 'Network transmit bytes in ' ~ result.projectName) }}
    </div>
  </div>
</wa-details>
{% if result.gpuEnabled %}
<wa-details open class="HtmRow" id="gpu-performance-dashboard">
  <div slot="summary">
    GPU Performance Metrics
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      {{ dashboardCard('visualization-cluster-gpu-temperature', 'GPU temperature per GPU device in cluster ' ~ result.clusterName ~ ' project ' ~ result.projectName) }}
      {{ dashboardCard('visualization-cluster-gpu-utilization', 'GPU utilization per GPU device in cluster ' ~ result.clusterName ~ ' project ' ~ result.projectName) }}
    </div>
  </div>
</wa-details>
<wa-details open class="HtmRow" id="llm-performance-dashboard">
  <div slot="summary">
    LLM Performance Metrics
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      {{ dashboardCard('visualization-llm-e2e-latency', 'LLM E2E Request Latency in ' ~ result.projectName) }}
      {{ dashboardCard('visualization-llm-token-throughput', 'LLM Token Throughput in ' ~ result.projectName) }}
    </div>
    <div class="wa-grid ">
      {{ dashboardCard('visualization-llm-ttft-latency', 'LLM Time To First Token in ' ~ result.projectName) }}
      {{ dashboardCard('visualization-llm-tpot-latency', 'LLM Time Per Output Token in ' ~ result.projectName) }}
    </div>
  </div>
</wa-details>
<wa-details open class="HtmRow" id="billing-section">
  <div slot="summary">
    Resource Utilization
  </div>
  <div class="wa-stack">
    <wa-card with-header>
      <header slot="header" class="wa-heading-m">GPU Hours Used</header>
      <table id="billing-gpu-hours-table" class="wa-zebra-rows wa-hover-rows" style="display: none; width: 100%;">
        <thead>
          <tr>
            <th style="text-align: left;">GPU Model</th>
            <th style="text-align: left;">Pod</th>
            <th style="text-align: left;">Node</th>
            <th style="text-align: right;">GPU Hours</th>
          </tr>
        </thead>
        <tbody id="billing-gpu-hours-tbody">
        </tbody>
        <tfoot>
          <tr>
            <th colspan="3" style="text-align: right;">Total GPU Hours:</th>
            <th id="billing-gpu-hours-total" style="text-align: right;"></th>
          </tr>
        </tfoot>
      </table>
      <div id="billing-gpu-hours-empty" style="display: none;">
        No GPU usage data found for the selected time range.
      </div>
      <wa-details summary="Query Info" style="margin-top: 1rem;">
        <table class="wa-zebra-rows">
          <tbody id="billing-range-info">
          </tbody>
        </table>
        <p style="margin-top: 0.5rem;"><strong>Query:</strong></p>
        <code id="billing-query-display" style="word-break: break-all;"></code>
      </wa-details>
    </wa-card>
    <wa-card with-header>
      <header slot="header" class="wa-heading-m">Storage Utilization</header>
      <div id="storage-quota-section" style="display: none; margin-bottom: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <strong>Storage Used:</strong>
          <span id="storage-used-text"></span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <strong>Storage Allocated:</strong>
          <span id="storage-allocated-text"></span>
        </div>
      </div>
      <table id="storage-utilization-table" class="wa-zebra-rows wa-hover-rows" style="display: none; width: 100%;">
        <thead>
          <tr>
            <th style="text-align: left;">PVC Name</th>
            <th style="text-align: center;">Status</th>
            <th style="text-align: right;">Allocated</th>
            <th style="text-align: right;">Used</th>
            <th style="text-align: right;">Usage %</th>
          </tr>
        </thead>
        <tbody id="storage-utilization-tbody">
        </tbody>
        <tfoot>
          <tr>
            <th colspan="2" style="text-align: right;">Totals:</th>
            <th id="storage-allocated-total" style="text-align: right;"></th>
            <th id="storage-used-total" style="text-align: right;"></th>
            <th id="storage-percent-total" style="text-align: right;"></th>
          </tr>
        </tfoot>
      </table>
      <div id="storage-utilization-empty" style="display: none;">
        No storage usage data found. PVCs must be mounted to running pods to show usage.
      </div>
      <wa-details summary="Query Info" style="margin-top: 1rem;">
        <p><strong>Quota Query:</strong></p>
        <code id="storage-quota-query-display" style="word-break: break-all;"></code>
        <p style="margin-top: 0.5rem;"><strong>PVC Allocated Query:</strong></p>
        <code id="storage-allocated-query-display" style="word-break: break-all;"></code>
        <p style="margin-top: 0.5rem;"><strong>Used Query:</strong></p>
        <code id="storage-used-query-display" style="word-break: break-all;"></code>
      </wa-details>
    </wa-card>
  </div>
</wa-details>
{% endif %}
{% endif %}
{%- endblock htmBodyStartProjectPage %}
{%- block htmStyleProjectPage %}
#visualization-cluster-gpu-nodes, #visualization-cluster-gpu-devices {
  wa-avatar {
    --size: 3em;
  }
}
#observability-dashboard {
  .pill {
    border-radius: var(--wa-border-radius-pill);
    box-shadow: var(--wa-theme-glossy-inner-shine), var(--wa-theme-glossy-top-highlight), inset 0 .7rem 0 0 rgba(255, 255, 255, 0.1), var(--wa-theme-glossy-lower-shade), var(--wa-theme-glossy-bottom-shadow);
    &:hover {
     background-color: var(--background-color-hover, var(--background-color));
      border-color: var(--border-color-hover, var(--border-color, var(--background-color-hover)));
      color: var(--text-color-hover, var(--text-color));
    }
  }
}
{%- endblock htmStyleProjectPage %}

{%- block facetChangeProjectSuccess %}
      updateDashboards();
{% endblock facetChangeProjectSuccess -%}

{%- block htmScriptInitProjectPage %}
      updateDashboards();
{%- endblock htmScriptInitProjectPage %}

{%- block htmScriptsProjectPage %}
{{ super() }}
  <script>

      function updateDashboards() {
        var facetRangeGapVal = document.querySelector("#pageSearchVal-pageFacetRangeGap-{{ classSimpleName }}-input").value;
        var startValue = document.querySelector("#pageSearchVal-pageFacetRangeStart-{{ classSimpleName }}-input").value;
        var endValue = document.querySelector("#pageSearchVal-pageFacetRangeEnd-{{ classSimpleName }}-input").value;
        var timeZone = document.querySelector("#pageFacetRangeTimeZoneInput").value;
        var start = moment.tz(startValue, 'YYYY-MM-DDTHH:mm', timeZone).utc().toISOString();
        var end = moment.tz(endValue, 'YYYY-MM-DDTHH:mm', timeZone).utc().toISOString();
        var step;
        switch (facetRangeGapVal) {
          case "+1YEAR":
            step = "1y";
            break;
          case "+1MONTH":
            step = "1M";
            break;
          case "+1DAY":
            step = "1d";
            break;
          case "+1HOUR":
            step = "1h";
            break;
          case "+1MINUTE":
            step = "1m";
            break;
          default:
            step = "7d";
        }

        var timeQuery = {
          start: start
          , end: end
          , step: step
          , timeZone: timeZone
        };

        // Time step for LLM metrics
        var llmTimeQuery = {
          start: start
          , end: end
          , step: "10m"
          , timeZone: timeZone
        };

        Promise.all([
            queryMemoryBytesTotal(timeQuery)
            , queryCpuBytesTotal(timeQuery)
            , {{ dashboardPromise('visualization-network-receive') }}
            , {{ dashboardPromise('visualization-network-transmit') }}
            {% if result.gpuEnabled -%}
            , queryGpuTemperature(timeQuery)
            , queryGpuUtilization(timeQuery)
            , queryLLME2ELatency(llmTimeQuery)
            , queryLLMTokenThroughput(llmTimeQuery)
            , queryLLMTTFTLatency(llmTimeQuery)
            , queryLLMTPOTLatency(llmTimeQuery)
            , queryGpuBillingHours('{{ result.hubId }}', '{{ result.clusterName }}', '{{ result.projectName }}', timeQuery)
            , queryStorageUtilization('{{ result.hubId }}', '{{ result.clusterName }}', '{{ result.projectName }}')
            {%- endif %}
            ]);
      }

    async function queryMemoryBytesTotal(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'namespace:container_memory_usage_bytes:sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-memory-bytes';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        responseJson.data.result.forEach((result, j) => {
          var hubId = hubIds[i];
          traces.push({
            x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
            , y: result.values.map(values => parseFloat(values[1]))
            , mode: 'scatter'
            , name: result.metric.cluster + ' in ' + hubId
            , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
          });
        });
      });
      var layout = {
        xaxis: {
          title: 'Time in ' + timeQuery.timeZone
        }
        , yaxis: {
          title: 'Total memory usage'
        }
        , legend: {
          title: {
            text: 'Projects'
          }
        }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryCpuBytesTotal(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var projectNamesFilter = '{% if result.clusterName is defined %}cluster="{{ result.clusterName | e }}", {% else %}{% endif %}namespace="{{ result.projectName }}"';
        var query = '{% if result.clusterName is defined %}node_namespace_pod_container:container_cpu_usage_seconds_total:sum{% else %}namespace:container_cpu_usage:sum{% endif %}{' + projectNamesFilter + '} / on({% if result.clusterName is defined %}cluster, {% endif %}namespace) namespace_cpu:kube_pod_container_resource_requests:sum{' + projectNamesFilter + '}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-cpu-bytes';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        responseJson.data.result.forEach((result, j) => {
          var hubId = hubIds[i];
          traces.push({
            x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
            , y: result.values.map(values => parseFloat(values[1]))
            , mode: 'scatter'
            , name: result.metric.cluster + ' in ' + hubId
            , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
          });
        });
      });
      var layout = {
        xaxis: {
          title: 'Time in ' + timeQuery.timeZone
        }
        , yaxis: {
          title: 'Percent of total CPU usage'
          , tickformat: '.0%'
        }
        , legend: {
          title: {
            text: 'Projects'
          }
        }
      };
      Plotly.newPlot(panelId, traces, layout);
    }
    {{ hubClusterProjectDashboardAsyncFunction(
      divId='visualization-network-receive'
      , yaxisTitle='Total network receive bytes'
      , classSimpleName='Project'
      , legendTitle='Projects'
      , metricPrefix='sum(irate(container_network_receive_bytes_total{'
      , metricSuffix='}[10m])) by (namespace)'
      , projectVar='projectName'
      , timeZone=timeZone
    ) }}
    {{ hubClusterProjectDashboardAsyncFunction(
      divId='visualization-network-transmit'
      , yaxisTitle='Total network transmit bytes'
      , classSimpleName='Project'
      , legendTitle='Projects'
      , metricPrefix='sum(irate(container_network_transmit_bytes_total{'
      , metricSuffix='}[10m])) by (namespace)'
      , projectVar='projectName'
      , timeZone=timeZone
    ) }}
    {% if result.gpuEnabled -%}

    async function queryGpuTemperature(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'DCGM_FI_DEV_GPU_TEMP{cluster="{{ result.clusterName }}",exported_namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var panelId = 'visualization-cluster-gpu-temperature';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data) {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'lines+markers'
              , name: hubId + ' ' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName
              , text: result.values.map(values => '<a href="/en-us/edit/ai-node/' + result.metric.cluster + '-' + result.metric.node + '">' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + '</a>')
            });
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
        , yaxis: { title: 'Temperature (Â°F)' }
        , legend: { title: { text: 'GPU Devices' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryGpuUtilization(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'DCGM_FI_DEV_GPU_UTIL{cluster="{{ result.clusterName }}",exported_namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-gpu-utilization';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data) {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'lines+markers'
              , name: result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + ' device ' + result.metric.gpu
              , text: result.values.map(values => '<a href="/en-us/edit/ai-node/' + result.metric.cluster + '-' + result.metric.node + '">' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + ' device ' + result.metric.gpu + '</a>')
            });
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLME2ELatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:e2e_request_latency_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:e2e_request_latency_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-e2e-latency';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            // Try to filter out responses that don't contain values
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Average (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'E2E Latency' } }
        , showlegend: true
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTokenThroughput(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      
      // Query for prompt tokens
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:prompt_tokens_total{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      // Query for generation tokens
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:generation_tokens_total{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-token-throughput';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      var halfLength = responseJsons.length / 2;
      
      // Process prompt tokens 
      for(var i = 0; i < halfLength; i++) {
        var responseJson = responseJsons[i];
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
                , y: result.values.map(values => parseFloat(values[1]))
                , mode: 'lines+markers'
                , name: 'Prompt Tokens/Sec (' + modelName + ')'
              });
            }
          });
        }
      }
      
      // Process generation tokens 
      for(var i = halfLength; i < responseJsons.length; i++) {
        var responseJson = responseJsons[i];
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
                , y: result.values.map(values => parseFloat(values[1]))
                , mode: 'lines+markers'
                , name: 'Generation Tokens/Sec (' + modelName + ')'
              });
            }
          });
        }
      }
      
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
        , yaxis: { title: 'Tokens per Second' }
        , legend: { title: { text: 'Token Throughput' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTTFTLatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:time_to_first_token_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:time_to_first_token_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-ttft-latency';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Average TTFT (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'TTFT Latency' } }
        , showlegend: true
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTPOTLatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:time_per_output_token_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:time_per_output_token_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-tpot-latency';
      populateDashboardDataQuery(panelId, urls, queries, timeQuery);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => moment.tz(values[0] * 1000, timeQuery.timeZone).format('YYYY-MM-DD HH:mm:ss'))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Mean TPOT (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in ' + timeQuery.timeZone }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'Time Per Output Token' } }
        , showlegend: true
      };
      Plotly.newPlot(panelId, traces, layout);
    }
    {%- endif %}

  </script>
{%- endblock htmScriptsProjectPage %}
