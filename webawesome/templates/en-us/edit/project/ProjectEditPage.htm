{% extends "en-us/edit/project/ProjectGenEditPage.htm" %}
{%- block htmBodyStartProjectPage %}
{{ super() }}
{% if result is defined %}
<wa-details open class="HtmRow" id="observability-dashboard">
  <div slot="summary">
    Observability dashboard for OpenShift projects
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      {{ dashboardCard('visualization-cluster-memory-bytes', 'Percent of total memory usage for ' ~ result.clusterName ~ ' cluster') }}
      {{ dashboardCard('visualization-cluster-cpu-bytes', 'Percent of total CPU usage for ' ~ result.clusterName ~ ' cluster') }}
    </div>
    <div class="wa-grid ">
      {{ dashboardCard('visualization-cluster-gpu-temperature', 'GPU temperature per GPU device in cluster ' ~ result.clusterName ~ ' project ' ~ result.projectName) }}
    </div>
    <div class="wa-grid ">
      {{ dashboardCard('visualization-cluster-gpu-utilization', 'GPU utilization per GPU device in cluster ' ~ result.clusterName ~ ' project ' ~ result.projectName) }}
    </div>
    <div class="wa-grid ">
      {{ dashboardCard('visualization-llm-e2e-latency', 'LLM E2E Request Latency in ' ~ result.projectName) }}
      {{ dashboardCard('visualization-llm-token-throughput', 'LLM Token Throughput in ' ~ result.projectName) }}
    </div>
    <div class="wa-grid ">
      {{ dashboardCard('visualization-llm-ttft-latency', 'LLM Time To First Token in ' ~ result.projectName) }}
      {{ dashboardCard('visualization-llm-tpot-latency', 'LLM Time Per Output Token in ' ~ result.projectName) }}
    </div>
  </div>
</wa-details>
{% endif %}
{%- endblock htmBodyStartProjectPage %}
{%- block htmStyleProjectPage %}
#visualization-cluster-gpu-nodes, #visualization-cluster-gpu-devices {
  wa-avatar {
    --size: 3em;
  }
}
#observability-dashboard {
  .pill {
    border-radius: var(--wa-border-radius-pill);
    box-shadow: var(--wa-theme-glossy-inner-shine), var(--wa-theme-glossy-top-highlight), inset 0 .7rem 0 0 rgba(255, 255, 255, 0.1), var(--wa-theme-glossy-lower-shade), var(--wa-theme-glossy-bottom-shadow);
    &:hover {
     background-color: var(--background-color-hover, var(--background-color));
      border-color: var(--border-color-hover, var(--border-color, var(--background-color-hover)));
      color: var(--text-color-hover, var(--text-color));
    }
  }
}
{%- endblock htmStyleProjectPage %}

{%- block facetSimpleRangeProjectSuccess %}
      updateDashboards();
{% endblock facetSimpleRangeProjectSuccess -%}

{%- block facetRangeTimeZoneProjectSuccess %}
      updateDashboards();
{% endblock facetRangeTimeZoneProjectSuccess -%}

{%- block facetRangeGapChangeProjectSuccess %}
      updateDashboards();
{% endblock facetRangeGapChangeProjectSuccess -%}

{%- block facetRangeStartChangeProjectSuccess %}
      updateDashboards();
{% endblock facetRangeStartChangeProjectSuccess -%}

{%- block facetRangeEndChangeProjectSuccess %}
      updateDashboards();
{% endblock facetRangeEndChangeProjectSuccess -%}

{%- block htmScriptInitProjectPage %}
      updateDashboards();
{%- endblock htmScriptInitProjectPage %}

{%- block htmScriptsProjectPage %}
{{ super() }}
  <script>

      function updateDashboards() {
        var facetRangeGapVal = document.querySelector("#pageSearchVal-pageFacetRangeGap-{{ classSimpleName }}-input").value;
        var startValue = document.querySelector("#pageSearchVal-pageFacetRangeStart-{{ classSimpleName }}-input").value;
        var endValue = document.querySelector("#pageSearchVal-pageFacetRangeEnd-{{ classSimpleName }}-input").value;
        var timeZone = document.querySelector("#pageFacetRangeTimeZoneInput").value;
        var start = moment.tz(startValue, 'YYYY-MM-DDTHH:mm', timeZone).utc().toISOString();
        var end = moment.tz(endValue, 'YYYY-MM-DDTHH:mm', timeZone).utc().toISOString();
        var step;
        switch (facetRangeGapVal) {
          case "+1YEAR":
            step = "1y";
            break;
          case "+1MONTH":
            step = "1M";
            break;
          case "+1DAY":
            step = "1d";
            break;
          case "+1HOUR":
            step = "1h";
            break;
          case "+1MINUTE":
            step = "1m";
            break;
          default:
            step = "7d";
        }

        var timeQuery = {
          start: start
          , end: end
          , step: step
        };

        // Time step for LLM metrics
        var llmTimeQuery = {
          start: start
          , end: end
          , step: "10m"
        };

        Promise.all([
            queryMemoryBytesTotal(timeQuery)
            , queryCpuBytesTotal(timeQuery)
            , queryGpuTemperature(timeQuery)
            , queryGpuUtilization(timeQuery)
            , queryLLME2ELatency(llmTimeQuery)
            , queryLLMTokenThroughput(llmTimeQuery)
            , queryLLMTTFTLatency(llmTimeQuery)
            , queryLLMTPOTLatency(llmTimeQuery)
            ]);
      }

    async function queryMemoryBytesTotal(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'namespace:container_memory_usage_bytes:sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-memory-bytes';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        responseJson.data.result.forEach((result, j) => {
          var hubId = hubIds[i];
          traces.push({
            x: result.values.map(values => new Date(values[0] * 1000))
            , y: result.values.map(values => parseFloat(values[1]))
            , mode: 'scatter'
            , name: result.metric.cluster + ' in ' + hubId
            , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
          });
        });
      });
      var layout = {
        xaxis: {
          title: 'Time in {{ defaultZoneId }}'
        }
        , yaxis: {
          title: 'Total memory usage'
        }
        , legend: {
          title: {
            text: 'Projects'
          }
        }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryCpuBytesTotal(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var projectNamesFilter = '{% if result.clusterName is defined %}cluster="{{ result.clusterName | e }}", {% else %}{% endif %}namespace="{{ result.projectName }}"';
        var query = '{% if result.clusterName is defined %}node_namespace_pod_container:container_cpu_usage_seconds_total:sum{% else %}namespace:container_cpu_usage:sum{% endif %}{' + projectNamesFilter + '} / on({% if result.clusterName is defined %}cluster, {% endif %}namespace) namespace_cpu:kube_pod_container_resource_requests:sum{' + projectNamesFilter + '}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-cpu-bytes';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        responseJson.data.result.forEach((result, j) => {
          var hubId = hubIds[i];
          traces.push({
            x: result.values.map(values => new Date(values[0] * 1000))
            , y: result.values.map(values => parseFloat(values[1]))
            , mode: 'scatter'
            , name: result.metric.cluster + ' in ' + hubId
            , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
          });
        });
      });
      var layout = {
        xaxis: {
          title: 'Time in {{ defaultZoneId }}'
        }
        , yaxis: {
          title: 'Percent of total CPU usage'
          , tickformat: '.0%'
        }
        , legend: {
          title: {
            text: 'Projects'
          }
        }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryGpuTemperature(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'DCGM_FI_DEV_GPU_TEMP{cluster="{{ result.clusterName }}",exported_namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var panelId = 'visualization-cluster-gpu-temperature';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data) {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => new Date(values[0] * 1000))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'lines+markers'
              , name: hubId + ' ' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName
              , text: result.values.map(values => '<a href="/en-us/edit/ai-node/' + result.metric.cluster + '-' + result.metric.node + '">' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + '</a>')
            });
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in {{ defaultZoneId }}' }
        , yaxis: { title: 'Temperature (Â°F)' }
        , legend: { title: { text: 'GPU Devices' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryGpuUtilization(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      hubIds.forEach((hubId, i) => {
        var query = 'DCGM_FI_DEV_GPU_UTIL{cluster="{{ result.clusterName }}",exported_namespace="{{ result.projectName }}"}';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);
      var end = new Date();
      var start = new Date(new Date().setHours(end.getHours() - 1));
      var panelId = 'visualization-cluster-gpu-utilization';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data) {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => new Date(values[0] * 1000))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'lines+markers'
              , name: result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + ' device ' + result.metric.gpu
              , text: result.values.map(values => '<a href="/en-us/edit/ai-node/' + result.metric.cluster + '-' + result.metric.node + '">' + result.metric.cluster + ' ' + result.metric.Hostname + ' ' + result.metric.modelName + ' device ' + result.metric.gpu + '</a>')
            });
          });
        }
      });
      var layout = {
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLME2ELatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:e2e_request_latency_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:e2e_request_latency_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-e2e-latency';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            // Try to filter out responses that don't contain values
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => new Date(values[0] * 1000))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Average (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in {{ defaultZoneId }}' }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'E2E Latency' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTokenThroughput(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      
      // Query for prompt tokens
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:prompt_tokens_total{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      // Query for generation tokens
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:generation_tokens_total{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-token-throughput';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      var halfLength = responseJsons.length / 2;
      
      // Process prompt tokens 
      for(var i = 0; i < halfLength; i++) {
        var responseJson = responseJsons[i];
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => new Date(values[0] * 1000))
                , y: result.values.map(values => parseFloat(values[1]))
                , mode: 'lines+markers'
                , name: 'Prompt Tokens/Sec (' + modelName + ')'
              });
            }
          });
        }
      }
      
      // Process generation tokens 
      for(var i = halfLength; i < responseJsons.length; i++) {
        var responseJson = responseJsons[i];
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => new Date(values[0] * 1000))
                , y: result.values.map(values => parseFloat(values[1]))
                , mode: 'lines+markers'
                , name: 'Generation Tokens/Sec (' + modelName + ')'
              });
            }
          });
        }
      }
      
      var layout = {
        xaxis: { title: 'Time in {{ defaultZoneId }}' }
        , yaxis: { title: 'Tokens per Second' }
        , legend: { title: { text: 'Token Throughput' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTTFTLatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:time_to_first_token_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:time_to_first_token_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-ttft-latency';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => new Date(values[0] * 1000))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Average TTFT (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in {{ defaultZoneId }}' }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'TTFT Latency' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

    async function queryLLMTPOTLatency(timeQuery) {
      const urls = [];
      const queries = [];
      const hubIds = ['{{ result.hubId }}'];
      var rateInterval = timeQuery.step;
      hubIds.forEach((hubId, i) => {
        var query = 'rate(vllm:time_per_output_token_seconds_sum{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + ']) / rate(vllm:time_per_output_token_seconds_count{cluster="{{ result.clusterName }}",namespace="{{ result.projectName }}"}[' + rateInterval + '])';
        queries.push(query);
        urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
            query: query 
            }, timeQuery)).toString());
      });
      const responses = await Promise.all(urls.map(url => fetch(url)));
      const dataPromises = responses.map(response => response.json());
      const responseJsons = await Promise.all(dataPromises);

      var panelId = 'visualization-llm-tpot-latency';
      populateDashboardDataQuery(panelId, urls, queries);

      var traces = [];
      responseJsons.forEach((responseJson, i) => {
        if(responseJson.data && responseJson.data.result) {
          responseJson.data.result.forEach((result, j) => {
            if(result.values && result.values.length > 0) {
              var modelName = result.metric.model_name || 'unknown';
              traces.push({
                x: result.values.map(values => new Date(values[0] * 1000))
                , y: result.values.map(values => parseFloat(values[1]) * 1000)
                , mode: 'lines+markers'
                , name: 'Mean TPOT (' + modelName + ')'
              });
            }
          });
        }
      });
      var layout = {
        xaxis: { title: 'Time in {{ defaultZoneId }}' }
        , yaxis: { title: 'Latency (ms)' }
        , legend: { title: { text: 'Time Per Output Token' } }
      };
      Plotly.newPlot(panelId, traces, layout);
    }

  </script>
{%- endblock htmScriptsProjectPage %}
